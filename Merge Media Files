#!/usr/bin/env bash
# Merge Media Files — universal Nautilus/Nemo/Caja/Thunar/Dolphin/PCManFM wrapper
# - Erkennt Dateiauswahl aus Nautilus-Variablen ODER aus Argumenten (%F)
# - Funktioniert somit ohne install.sh in vielen Dateimanagern
# - Beibehaltung aller bisherigen Features (Re-Encode-Abfrage, Fortschrittsfenster, Logging)

set -o errexit -o nounset -o pipefail

LOGFILE="/tmp/catmerge.log"
exec >>"$LOGFILE" 2>&1
echo "---- $(date) start ----"

# -------------------- kleine Utils --------------------
bin_exists() { command -v "$1" >/dev/null 2>&1; }

# Prozent-Decoding (aus file:// URIs) – bevorzugt python3, Fallback: nur %20 -> Leerzeichen
uridecode() {
  if bin_exists python3; then
    python3 - "$@" <<'PY'
import sys, urllib.parse
for s in sys.argv[1:]:
    if s.startswith('file://'):
        s = urllib.parse.unquote(s[7:])
    print(s)
PY
  else
    # Minimal-Fallback: nur 'file://' entfernen und %20 zu Leerzeichen machen
    for s in "$@"; do
      s="${s#file://}"
      printf '%s\n' "${s//%20/ }"
    done
  fi
}

# -------------------- Abhängigkeiten prüfen --------------------
need_cmds=("ffmpeg" "yad")
missing=()
for c in "${need_cmds[@]}"; do
  bin_exists "$c" || missing+=("$c")
done

if ((${#missing[@]})); then
  rpmfusion_hint=""
  if printf '%s\n' "${missing[@]}" | grep -q '^ffmpeg$'; then
    rpmfusion_hint=$'\nHinweis (Fedora): ffmpeg ist i. d. R. in RPM Fusion.\n  sudo dnf install -y https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm\n  sudo dnf install -y ffmpeg'
  fi
  msg=$'Fehlende Abhängigkeiten: '"${missing[*]}"$'\n\nUbuntu/Debian:  sudo apt install ffmpeg yad\nFedora:         sudo dnf install yad\n                (ffmpeg über RPM Fusion)\n'"${rpmfusion_hint}"
  if bin_exists yad; then
    yad --title="Abhängigkeiten fehlen" --text="$msg" --button="OK":0 --center || true
  elif bin_exists zenity; then
    zenity --info --title="Abhängigkeiten fehlen" --text="$msg" || true
  else
    echo "$msg" >&2
  fi
  exit 1
fi

# -------------------- Dateiauswahl universell einsammeln --------------------
# Priorität:
# 1) NAUTILUS_SCRIPT_SELECTED_FILE_PATHS (Nautilus/Nemo/Caja)
# 2) NAUTILUS_SCRIPT_SELECTED_URIS (als file:// URIs)
# 3) Argumente (%F) aus Thunar/Dolphin/PCManFM(-Qt)

SELECTED_LINES=""
if [[ -n "${NAUTILUS_SCRIPT_SELECTED_FILE_PATHS:-}" ]]; then
  SELECTED_LINES="$(printf '%s\n' "${NAUTILUS_SCRIPT_SELECTED_FILE_PATHS}" | sed '/^$/d')"
elif [[ -n "${NAUTILUS_SCRIPT_SELECTED_URIS:-}" ]]; then
  # in Pfade umwandeln
  mapfile -t paths < <(uridecode ${NAUTILUS_SCRIPT_SELECTED_URIS})
  SELECTED_LINES="$(printf '%s\n' "${paths[@]}" | sed '/^$/d')"
elif (($#>0)); then
  # Argumente als Pfade
  mapfile -t paths < <(printf '%s\n' "$@")
  SELECTED_LINES="$(printf '%s\n' "${paths[@]}" | sed '/^$/d')"
else
  if bin_exists yad; then
    yad --image=dialog-error --text="Keine Dateien ausgewählt/übergeben." --button="OK":0 --center || true
  else
    echo "Keine Dateien ausgewählt/übergeben." >&2
  fi
  exit 1
fi

# Sicherstellen, dass alle Pfade existieren (nur Dateien)
FILES_RAW="$(printf '%s\n' "${SELECTED_LINES}" | while IFS= read -r p; do [[ -f "$p" ]] && printf '%s\n' "$p"; done)"
if [[ -z "${FILES_RAW}" ]]; then
  echo "Keine gültigen Dateien gefunden." >&2
  exit 1
fi

# -------------------- Ausgangswerte/Metadaten --------------------
FIRST_FILE="$(printf '%s\n' "${FILES_RAW}" | head -n 1)"
DIRNAME="$(dirname "${FIRST_FILE}")"
EXTENSION_RAW="${FIRST_FILE##*.}"
EXTENSION="${EXTENSION_RAW,,}"   # in Kleinbuchstaben
BASENAME="$(basename "${FIRST_FILE}" | sed -E 's/_[0-9]{3}\.[^.]+$//')"
TIMESTAMP="$(stat -c %y "${FIRST_FILE}" | cut -d' ' -f1)"
OUTPUT_FILE="${BASENAME}_${TIMESTAMP}.${EXTENSION}"

# Sortierung (natürlich aufsteigend), nur existierende Dateien
SORTED_FILES="$(printf '%s\n' "${FILES_RAW}" | sort -V)"

echo "FIRST_FILE=$FIRST_FILE"
echo "DIRNAME=$DIRNAME"
echo "EXTENSION=$EXTENSION"
echo "OUTPUT_FILE=$OUTPUT_FILE"

# --- Anzeige der Reihenfolge (vertikale Liste, nur Basename, dynamische Höhe) ---
get_screen_height() {
  if command -v xrandr >/dev/null 2>&1; then
    # Beispielausgaben: "1920x1080" oder "connected primary 1920x1080+..."
    xrandr | awk '/*/{if($1=="*"||$2=="*"){print $1; exit}}' 2>/dev/null | cut -d'x' -f2 || \
    xrandr | awk '/current/{print $8; exit}' 2>/dev/null
  elif command -v xdpyinfo >/dev/null 2>&1; then
    xdpyinfo | awk '/dimensions:/{split($2,a,"x"); print a[2]; exit}' 2>/dev/null
  else
    echo 900
  fi
}

SCREEN_H="$(get_screen_height)"
: "${SCREEN_H:=500}"
MAX_H="$(( SCREEN_H * 75 / 100 ))"
MIN_H=300
HEIGHT=$(( MAX_H > MIN_H ? MAX_H : MIN_H ))

# Nur die Basisnamen vorbereiten (robust gegen Leerzeichen)
TMP_NAMES="$(mktemp)"
while IFS= read -r f; do
  [ -n "$f" ] || continue
  printf '%s\n' "$(basename "$f")" >> "$TMP_NAMES"
done <<< "$SORTED_FILES"

# Liste per STDIN an yad geben: eine Zeile = eine Tabellenzeile
if command -v yad >/dev/null 2>&1; then
  yad --title="Zusammenfügen bestätigen" \
      --text="Die folgenden Dateien werden in dieser Reihenfolge zusammengefügt:" \
      --list --no-headers --no-click --scroll \
      --column="Dateien" \
      --width=500 --height="$HEIGHT" --center \
      --button="Abbrechen":1 --button="OK":0 \
      < "$TMP_NAMES" || { rm -f "$TMP_NAMES"; exit 1; }
fi

rm -f "$TMP_NAMES"

# -------------------- Speicherplatz prüfen --------------------
REQUIRED_SPACE=0
while IFS= read -r f; do
  sz=$(du -k -- "$f" | awk '{print $1}')
  REQUIRED_SPACE=$((REQUIRED_SPACE + sz))
done <<< "${SORTED_FILES}"
AVAILABLE_SPACE=$(df -Pk -- "${DIRNAME}" | awk 'END{print $4}')

echo "REQUIRED_SPACE=${REQUIRED_SPACE} KB, AVAILABLE_SPACE=${AVAILABLE_SPACE} KB"

if (( AVAILABLE_SPACE < REQUIRED_SPACE )); then
  if bin_exists yad; then
    yad --image=dialog-error --button=gtk-ok:0 --center --text="Nicht genügend Speicherplatz verfügbar!" || true
  else
    echo "Nicht genügend Speicherplatz." >&2
  fi
  exit 1
fi

cd "${DIRNAME}"

# -------------------- ffmpeg-Listendatei (concat demuxer) --------------------
LIST_FILE="$(mktemp)"
while IFS= read -r line; do
  [[ -n "$line" ]] || continue
  printf "file '%s'\n" "$line" >> "${LIST_FILE}"
done <<< "${SORTED_FILES}"

echo "LIST_FILE at ${LIST_FILE}:"
cat "${LIST_FILE}"

# -------------------- Copy-Test (kurz) --------------------
NEED_REENCODE=0
if ffmpeg -hide_banner -v error -f concat -safe 0 -i "${LIST_FILE}" -c copy -t 0.1 -f null - </dev/null 2>/dev/null; then
  NEED_REENCODE=0
else
  NEED_REENCODE=1
fi
echo "NEED_REENCODE=$NEED_REENCODE"

# Nachfrage bei Re-Encode
if (( NEED_REENCODE == 1 )); then
  if bin_exists yad; then
    yad --title="Neukodierung erforderlich" --text="Die Dateien müssen neukodiert werden. Fortfahren?" --button="Nein":1 --button="Ja":0 || { rm -f "${LIST_FILE}"; exit 1; }
  fi
fi

# -------------------- Fortschritts-UI via FIFO (immer sichtbar) --------------------
PROG_FIFO="$(mktemp -u)"
mkfifo "$PROG_FIFO"
if bin_exists yad; then
  yad --progress --pulsate --no-cancel --auto-close --title="Zusammenfügen läuft" --text="# Bitte warten..." < "$PROG_FIFO" &
  YAD_PID=$!
  echo "YAD_PID=$YAD_PID"
fi

set +e
FF_ERR=0
if (( NEED_REENCODE == 1 )); then
  case "${EXTENSION}" in
    mp4|mov|mkv)
      ffmpeg -y -f concat -safe 0 -i "${LIST_FILE}" -c:v libx264 -preset fast -crf 23 -c:a aac "${OUTPUT_FILE}" || FF_ERR=$?
      ;;
    mp3|aac|ogg)
      ffmpeg -y -f concat -safe 0 -i "${LIST_FILE}" -c:a libmp3lame "${OUTPUT_FILE}" || FF_ERR=$?
      ;;
    wav|flac)
      ffmpeg -y -f concat -safe 0 -i "${LIST_FILE}" -c:a flac "${OUTPUT_FILE}" || FF_ERR=$?
      ;;
    *)
      ffmpeg -y -f concat -safe 0 -i "${LIST_FILE}" -c copy "${OUTPUT_FILE}" || FF_ERR=$?
      ;;
  esac
else
  ffmpeg -y -f concat -safe 0 -i "${LIST_FILE}" -c copy "${OUTPUT_FILE}" || FF_ERR=$?
fi

# Fortschritt schließen / Meldung
{
  echo 100
  echo "# Fertig."
} > "$PROG_FIFO"

rm -f "$PROG_FIFO" "${LIST_FILE}"

if (( FF_ERR != 0 )); then
  echo "ffmpeg exit code: $FF_ERR"
  if bin_exists yad; then
    yad --image=dialog-error --text="Fehler beim Zusammenfügen (Code $FF_ERR).\nSiehe Log: $LOGFILE" --button="OK":0 --center || true
  else
    echo "Fehler beim Zusammenfügen (Code $FF_ERR). Siehe Log: $LOGFILE" >&2
  fi
  exit "$FF_ERR"
else
  if bin_exists yad; then
    yad --image=dialog-information --text="Erfolg: ${OUTPUT_FILE}" --button="OK":0 --center || true
  else
    echo "Erfolg: ${OUTPUT_FILE}"
  fi
fi

echo "---- $(date) end ----"
